C51 COMPILER V9.51   MAIN                                                                  03/16/2015 15:12:35 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN Main.OBJ
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE Main.c COMPACT BROWSE INCDIR(..\Library) DEBUG OBJECTEX
                    -TEND TABS(3)

line level    source

   1          /*---------------------------------------------------
   2             main.c (v1.00)
   3             
   4             DDC-Z program, for electrocar.
   5          ----------------------------------------------------*/
   6          
   7          //µç¶¯³µ
   8          #include "Main.h"
   9          #include "port.h"
  10          
  11          #include "AD.h"
  12          #include "voice.h"
  13          #include "pwm.h"
  14          #include "Timer.h"
  15          #include "Delay.h"
  16          #include "communication.h"
  17          #include "Battery.h"
  18          #include "Other.h"
  19          #include "operation.h"
  20          #include "UART.h"
  21          #include "ISP_DataFlash.h"
  22          #include "schedular.h"
  23          #include "ElecMotor.h"
  24          
  25                                                  
  26          /*------- Public variable declarations --------------------------*/
  27          extern tByte timer0_8H, timer0_8L, timer1_8H, timer1_8L;
  28          extern bit enable_sensor_delayEN;
  29          
  30          // ------ Private variable definitions -----------------------------
  31          bit stolen_alarm_flag = 0;             // when host been touch 3 times, this flag 1 before alarm voice present, no
             -t to detect sensor for 1st voice alarm.
  32          bit position_sensor_EN=0;        //Î»ÖÃ´«¸ĞÆ÷£¬¼´µ¹µØÌ§Æğ´«¸ĞÆ÷×Ü¿ª¹Ø£¬1µÄÊ±ºò£¬¼ì²âÕâÁ½¸ö´«¸ĞÆ÷
  33          bit host_stolen_alarm1_EN = 0;      //ÅĞ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚÒ»¶ÎÓïÒôÊ¹ÄÜ
  34          bit host_stolen_alarm2_EN = 0;      //ÅĞ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚ¶ş¶ÎÓïÒôÊ¹ÄÜ
  35          tByte host_stolen_alarm1_count = 0;    //ÅĞ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚÒ»¶ÎÓïÒô´ÎÊı
  36          tByte host_stolen_alarm2_count = 0;    //ÅĞ¶ÏÎª±»µÁ±¨¾¯ºóµÄµÚ¶ş¶ÎÓïÒô´ÎÊı
  37          bit fell_flag=0;                 //ÅĞ¶ÏÖ÷»úµ¹ÏÂºó£¬ÖÃ1
  38          bit raised_flag=0;               //ÅĞ¶ÏÖ÷»ú±»Ì§Æğºó£¬ÖÃ1
  39          tByte sensor_2ndstage_count = 0;    //´«¸ĞÆ÷½øÈëµÚ¶ş½×¶Î¼ì²âÊ±£¬¼ÆËãµÍµçÆ½µÄÊ±¼ä
  40          tWord sensor_3rdstage_time = 0;        //´«¸ĞÆ÷½øÈëµÚÈı½×¶ÎµÄÊ±¼ä£¬
  41          tByte sensor_3rdstage_effcount = 0;    //´«¸ĞÆ÷½øÈëµÚÈı½×¶Îºó£¬ÓĞĞ§´¥Åö´ÎÊıµÄ¼ÆÊı
  42          tByte sensor_3rdstage_count = 0;       //´«¸ĞÆ÷½øÈëµÚÈı½×¶Îºó£¬µÍµçÆ½µÄ¼ÆÊı
  43          tWord sensor_3rdstage_interval = 0;    //´«¸ĞÆ÷ÔÚµÚÈı½×¶ÎÖĞ£¬Ã¿´ÎÓĞĞ§µÍµçÆ½¼ÆÊıÖ®¼äµÄÊ±¼ä¼ä¸ô¡£ÔÚÕâÆÚ¼äµÄµÍµ
             -çÆ½²»ÈÏÎªÓĞĞ§¡£
  44          bit raised_fell_flag = 0;              //µ¹µØ»òÕßÌ§Æğ´¥·¢ºó£¬´Ë±êÖ¾Î»ÖÃ1
  45          tByte sensor_trigger_count=0;    //´«¸ĞÆ÷´¥·¢¼ÆÊı
  46          tWord sensor_2ndstage_time=0;    //´«¸ĞÆ÷½øÈëµÚ¶ş½×¶ÎºóÁ÷ÊÅÊ±¼äµÄ¼ÆÊı
  47          tByte sensor_1ststage_count=0;   //´«¸ĞÆ÷µÚÒ»½×¶ÎÅĞ¶ÏµÍµçÆ½µÄ¼ÆÊı
  48          tByte nearby_away_interval = 0;     //¸½»úÀë¿ªºÍ¿¿½üÊ±£¬ÓïÒôÌáÊ¾ºÍ¿ª¹ØËøµÄÊ±¼ä¼ä¸ô
  49          
  50          tByte raised_alarm_count = 0;    //Ö÷»ú±»Ì§Æğºó£¬Ïò¸½»ú·¢³ö±¨¾¯ĞÅºÅµÄ´ÎÊı
  51          tByte fell_alarm_count=0;        //Ö÷»úµ¹µØºó£¬Ïò¸½»ú·¢³ö±¨¾¯ĞÅºÅµÄ´ÎÊı
  52          tWord timer0_count=0;      // counter for timer0, increment every ticket         
C51 COMPILER V9.51   MAIN                                                                  03/16/2015 15:12:35 PAGE 2   

  53          tByte received_data_buffer[7]={0x00,0x00,0x00,0x00,0x00,0x00,0x00};     //½ÓÊÕÊı¾İ»º´æ
  54          bit receive_data_finished_flag = 0;    //½ÓÊÕÕâÒ»´®Êı¾İÍê³Éºó£¬´Ë±êÖ¾Î»ÖÃ1
  55          tByte data_count = 0;            //½ÓÊÕÊı¾İ»º´æµÄÎ»Êı£¬¼´±íÃ÷µÚ¼¸¸ö»º´æÊı¾İ
  56          tByte one_receive_byte = 0;      //½ÓÊÕÊı¾İµÄÒ»¸ö×Ö½Ú£¬½ÓÊÕÍêºó½«Æä¸³Öµ¸øreceived_data_bufferÏà¶ÔÓ¦µÄ×Ö½Ú
  57          tByte one_receive_byte_count = 0;         //one_receive_byteÓĞ8Î»£¬´Ë¼ÆÊı±íÃ÷½ÓÊÕµ½µÚ¼¸Î»£¬Ã¿´Î¼ÆÊıµ½8µÄÊ±ºò±íÃ÷
             -Ò»¸ö×Ö½Ú½ÓÊÕÍê³É¡£
  58          bit receive_wire_flag = 1;    //½ÓÊÕÍ¨ĞÅÏßµÄ±êÖ¾Î»£¬1±íÃ÷¸ßµçÆ½£¬0±íÃ÷µÍµçÆ½£¬Ã¿´Îtimer1Òç³öÊ±£¬ÅĞ¶ÏP1.1Ò»´Î
             -¡£ÒÔ´ËÀ´±íÃ÷ÊÇ·ñÎªÒ»´ÎÕıÈ·µÄÏÂ½µÑØ
  59          tByte receive_HV_count = 0;      //¶¨Ê±Æ÷T1ÔÚÃ»ÓĞĞÅºÅµ½À´µÄÊ±ºò£¬¶Ô¸ßµçÆ½¼ÆÊı£¬Ò»µ©³¬¹ıÄ³¸öÖµ£¬Ôò½«one_receive
             -_byte_countÇå0
  60          tByte receive_LV_count = 0;      //Ã¿´Îtimer1Òç³öÊ±ÅĞ¶Ï½ÓÊÕÏßÈç¹ûÎªLV£¬Ôò¼ÆÊı¼Ó1£¬ÒÔ´ËÀ´±íÃ÷µÍµçÆ½µÄÊ±¼ä
  61          tByte fell_wire_time=0;         //µ¹µØ¼ì²âÏß£¬¼ì²âµÍµçÆ½µÄÊ±¼ä
  62          tByte raise_wire_time=0;         //Ì§Æğ¼ì²âÏß£¬¼ì²âµÍµçÆ½µÄÊ±¼ä
  63          tWord raised_fell_number = 0;          //µ¹µØ»òÕßÌ§Æğ³ö·¢ºó£¬¼ÆÊı£¬µ½´ïÒ»¶¨ÊıÖµºó£¬½«ÆäÓë±êÖ¾Î»Ò»ÆğÇåÁã¡£
  64          bit raised_fell_once_flag = 0;         //raised_fell_flagÊÇ·ñÔø¾­±êÖ¾¹ı£¬Èç¹û±êÖ¾¹ıÔòÖÃ1.È»ºóÖ÷»ú±»»Ö¸´µ¹µØ»òÕß»
             -Ö¸´Ì§ÆğÊ±£¬´Ë±êÖ¾Î»¸´Î»¡£
  65          tByte key_rotated_on_flag = 0;         //µç¶¯³µ¿ªÆô¹Ø±Õ±êÖ¾Î»£¬1±íÊ¾µç¶¯³µ¿ªÆôÁË£¬0±íÊ¾µç¶¯³µ¹Ø±ÕÁË
  66          tWord ADC_check_result = 0;      //×÷ÎªAD¼ì²âÖµ
  67          tByte wire_broken_count = 0;     // ×÷Îª¶ÏÏßºóµÄÊ±¼ä¼ì²â
  68          bit battery_stolen_EN = 0;       // ×÷Îªµç³Ø±»µÁµÄÊ¹ÄÜ¶Ë
  69          tByte battery_stolen_count = 0;  // ×÷Îªµç³Ø±»µÁµÄ±¨¾¯´ÎÊı
  70          bit horizontal_vibration = 0;    // ±íÊ¾´¹Ö±´«¸ĞÆ÷ÔÚÕñ¶¯£¬´ËÊ±¾ÍËã¹ØÔ¿³×£¬Ò²²»ÄÜÖ´ĞĞ¹ØÔ¿³×µÄ²Ù×÷¡
  71          tWord horizontal_vibration_count = 0;  //´¹Ö±´«¸ĞÆ÷´¥·¢ºó£¬¶ÔÊ±¼ä½øĞĞ¼ÆÊı¡£
  72          bit vibration_flag = 0;
  73          tWord vibration_count = 0;
  74          bit wire_broken_flag = 0;        // ¼ô¶ÏËøÏßµÄ±êÖ¾Î»
  75          bit IDkey_flag = 0;        // µ±ID¿¨¿¿½üÊ±ÈÏÖ¤Í¨¹ıºóÖÃ1£¬
  76          tByte IDkey_count = 0;     // ID¿¨ÈÏÖ¤Í¨¹ıºó£¬¼ÆÊ±1·ÖÖÓ£¬Ê¹Ô¿³×ÄÜ×ª¶¯¡£
  77          bit sensor_EN = 0;
  78          tByte enable_sensor_delay_count = 0;      // ´«¸ĞÆ÷ÑÓ³ÙµÄÊ±¼ä
  79          bit sensor_3rdalarm_flag = 0;
  80          bit wheeled_flag = 0;
  81          tWord wheeled_count = 0;
  82          bit IDkey_speech_flash = 0;
  83          
  84          code tByte IDkey6 _at_ 0x003000;
  85          code tByte IDkey7 _at_ 0x003001;
  86          code tByte IDkey8 _at_ 0x003002;
  87          code tByte IDkey9 _at_ 0x003003;
  88          code tByte IDkey10 _at_ 0x003004;
  89          code tByte IDkey11 _at_ 0x003005;
  90          
  91          tWord IDkey_selflearn_HVcount = 0;
  92          tWord IDkey_selflearn_LVcount = 0;
  93          bit IDkey_selflearn_flag1 = 0;
  94          bit IDkey_selflearn_flag2 = 0;
  95          bit IDkey_selflearn_flag3 = 0;
  96          bit IDkey_selflearn_flag4 = 0;
  97          bit IDkey_selflearn_flag5 = 0;
  98          bit IDkey_selflearn_flag6 = 0;
  99          tByte IDkey_selflearn_flag4count = 0;
 100          bit IDkey_flash_EN = 0;
 101          
 102          tByte IDkey_certificated_times = 0;
 103          bit Silence_Flag = 0;
 104          bit flashing_flag = 0;
 105          
 106          tByte CheckADC_count = 0;
 107          bit CheckADC_flag = 0;
 108          
 109          /*------- Private variable declarations --------------------------*/
 110          
C51 COMPILER V9.51   MAIN                                                                  03/16/2015 15:12:35 PAGE 3   

 111          void main()
 112             {  
 113   1      
 114   1         noVoice();
 115   1         
 116   1         InitUART9600();
 117   1      
 118   1         sensor_EN = 0;
 119   1         position_sensor_EN = 0;
 120   1         enable_sensor_delayEN = 1;
 121   1         
 122   1         raised_sensor_detect = 1;
 123   1         fell_sensor_detect = 1;
 124   1      
 125   1         P10=1;
 126   1         CheckADC();
 127   1      // horizontal_sensor = 1;
 128   1         
 129   1         // turn off transmitter, turn on receiver
 130   1         transmiter_EN = 1;
 131   1         receiver_EN = 0;
 132   1      
 133   1      
 134   1         nearby_away_interval = 6;        //³õÊ¼»¯Ê¹¸½»úºÍÖ÷»ú¿ª¹Ø»úµÄ¼ÆÊıÎª¿ÉÒÔÖ´ĞĞµÄ×´Ì¬
 135   1         
 136   1         // initialize the magnet, 
 137   1         MagentControl_1 = 1;
 138   1         MagentControl_2 = 1;
 139   1         magnet_ACW(5000, 8000);
 140   1         
 141   1         transmiter_power = 1; 
 142   1         voice_EN=0;    //½«¹¦·Å¹Ø±Õ
 143   1         
 144   1         // lock the external motor, ·ÀÖ¹Ëø»¹Ã»ÍêÈ«´ò¿ªµÄÊ±ºò£¬³µÊÖ¼Óµçµ¼ÖÂÂÖ×ÓÓëËøµÄ¸æËßÅö×²¡£ 
 145   1         motor_lock = 1;
 146   1         TR0 = 1;
 147   1         
 148   1         while(1)
 149   1            {
 150   2            SCH_Dispatch_Tasks();
 151   2            
 152   2            // whether host has been touched 3 times, if yes, then alarm 2 speech alternantively.
 153   2            if((host_stolen_alarm1_EN == 1)&&(host_stolen_alarm1_count < 4))
 154   2               {
 155   3               stolen_alarm_flag = 1;
 156   3               if(key_rotate == 0)
 157   3                  {
 158   4      //          SCH_Add_Task(stolen_alarm_speech1, 0, 0);
 159   4                  stolen_alarm_speech1();
 160   4                  }
 161   3               if(++host_stolen_alarm1_count >= 4)
 162   3                  {
 163   4                  host_stolen_alarm1_count = 0;
 164   4                  host_stolen_alarm1_EN = 0;
 165   4                  stolen_alarm_flag = 0;
 166   4                  sensor_3rdalarm_flag = 0;
 167   4                  }
 168   3               }
 169   2            if((host_stolen_alarm2_EN == 1)&&(host_stolen_alarm2_count < 4))
 170   2               {
 171   3               stolen_alarm_flag = 1;
 172   3               if(key_rotate == 0)
C51 COMPILER V9.51   MAIN                                                                  03/16/2015 15:12:35 PAGE 4   

 173   3                  {
 174   4      //          SCH_Add_Task(stolen_alarm_speech2, 0, 0);
 175   4                  stolen_alarm_speech2();
 176   4                  }
 177   3               if(++host_stolen_alarm2_count >= 4)
 178   3                  {
 179   4                  host_stolen_alarm2_count = 0;
 180   4                  host_stolen_alarm2_EN = 0;
 181   4                  stolen_alarm_flag = 0;
 182   4                  sensor_3rdalarm_flag = 0;
 183   4                  }
 184   3               }
 185   2            }
 186   1         }
 187          
 188          /*------------------------------------------------------------------
 189             timerT0()
 190             operation every ticket.
 191          --------------------------------------------------------------------*/
 192          
 193          void timer0() interrupt interrupt_timer_0_overflow
 194             {
 195   1         // manually reload timer0 configuration
 196   1         TH0 = timer0_8H;
 197   1         TL0 = timer0_8L;
 198   1         
 199   1         // timer0 is 1ms ticket, count the time flow of timer0, then operate every 2s.
 200   1         if(++timer0_count >= 2000)
 201   1            {
 202   2            // reset timer0 ticket counter every 2s
 203   2            timer0_count=0;
 204   2            
 205   2            // Check Battery's voltage
 206   2      //       SCH_Add_Task(CheckADC, 0, 0);
 207   2            if(key_rotated_on_flag == 1)
 208   2               {
 209   3               CheckADC();
 210   3      /*       if((++CheckADC_count > 4)&&(CheckADC_flag == 0))
 211   3                  {
 212   3                  CheckADC_count = 10;
 213   3                  CheckADC_flag = 1;
 214   3                  
 215   3                  if(Silence_Flag == 0)
 216   3                     verifybattery(ADC_check_result);
 217   3                  }
 218   3      */
 219   3               }
 220   2            
 221   2            if(IDkey_flag == 1)
 222   2               {
 223   3               if(++IDkey_count >= 5)
 224   3                  {
 225   4                  IDkey_count = 0;
 226   4                  IDkey_flag = 0;
 227   4                  IDkey_certificated_times = 0;
 228   4                  if(key_rotated_on_flag == 0)
 229   4                     {
 230   5                     enable_sensor();              
 231   5                     }
 232   4                  }        
 233   3               }
 234   2                     
C51 COMPILER V9.51   MAIN                                                                  03/16/2015 15:12:35 PAGE 5   

 235   2            if((enable_sensor_delayEN == 1)&&(key_rotate == 0))
 236   2               {
 237   3               if(++enable_sensor_delay_count >= 3)
 238   3                  {
 239   4                  enable_sensor_delay_count = 0;
 240   4                  enable_sensor_delayEN = 0;
 241   4                  enable_sensor();
 242   4                  }
 243   3               }
 244   2      
 245   2            if(IDkey_selflearn_flag4 == 1)
 246   2               {
 247   3               if(++IDkey_selflearn_flag4count > 5)
 248   3                  {
 249   4                  IDkey_selflearn_HVcount = 0;
 250   4                  IDkey_selflearn_LVcount = 0;
 251   4                  IDkey_selflearn_flag1 = 0;
 252   4                  IDkey_selflearn_flag2 = 0;
 253   4                  IDkey_selflearn_flag3 = 0;
 254   4                  IDkey_selflearn_flag4 = 0;
 255   4                  IDkey_selflearn_flag4count = 0;           
 256   4                  }        
 257   3               }
 258   2            }  
 259   1      
 260   1         if(IDkey_speech_flash == 1)
 261   1            {
 262   2            IDkey_speech_flash = 0;
 263   2      //    SCH_Add_Task(ID_speech, 0, 0);
 264   2            ID_speech();
 265   2            SCH_Delete_Program(stolen_alarm_speech1);
 266   2            SCH_Delete_Program(stolen_alarm_speech2);
 267   2            }
 268   1      
 269   1         if(key_rotate == 1)
 270   1            {
 271   2            IDkey_selflearn_LVcount = 0;
 272   2                     
 273   2            if(++IDkey_selflearn_HVcount > 4000)
 274   2               {
 275   3               IDkey_selflearn_HVcount = 4002;
 276   3               IDkey_selflearn_flag1 = 0;
 277   3               IDkey_selflearn_flag2 = 0;
 278   3               IDkey_selflearn_flag3 = 0;
 279   3               IDkey_selflearn_flag4 = 0;
 280   3               IDkey_selflearn_flag5 = 0;
 281   3               }
 282   2            else
 283   2               {
 284   3               IDkey_selflearn_flag1 = 1;
 285   3               if(IDkey_selflearn_flag2 == 1)
 286   3                  IDkey_selflearn_flag3 = 1;
 287   3               if(IDkey_selflearn_flag4 == 1)
 288   3                  IDkey_selflearn_flag5 = 1;
 289   3               }
 290   2            }
 291   1         else
 292   1            {
 293   2            IDkey_selflearn_HVcount = 0;
 294   2            
 295   2            if(IDkey_selflearn_flag1 == 1)
 296   2               IDkey_selflearn_flag2 = 1;
C51 COMPILER V9.51   MAIN                                                                  03/16/2015 15:12:35 PAGE 6   

 297   2               
 298   2            if(IDkey_selflearn_flag3 == 1)
 299   2               IDkey_selflearn_flag4 = 1;
 300   2            
 301   2            if(IDkey_selflearn_flag5 == 1)
 302   2               IDkey_selflearn_flag6 = 1;
 303   2            
 304   2            if(++IDkey_selflearn_LVcount > 4000)
 305   2               {
 306   3               IDkey_selflearn_LVcount = 4002;
 307   3               IDkey_selflearn_flag1 = 0;
 308   3               IDkey_selflearn_flag2 = 0;
 309   3               IDkey_selflearn_flag3 = 0;
 310   3               IDkey_selflearn_flag4 = 0;
 311   3               IDkey_selflearn_flag5 = 0;
 312   3               IDkey_selflearn_flag6 = 0;
 313   3               }
 314   2            }
 315   1      
 316   1      
 317   1      
 318   1         if(IDkey_flash_EN == 1)
 319   1            {
 320   2            IDkey_flash_EN = 0;
 321   2            flashing_flag = 1;
 322   2            IDkey_selflearn_flag1 = 0;
 323   2            IDkey_selflearn_flag2 = 0;
 324   2            IDkey_selflearn_flag3 = 0;
 325   2            IDkey_selflearn_flag4 = 0;
 326   2            IDkey_selflearn_flag5 = 0;
 327   2            IDkey_selflearn_flag6 = 0;
 328   2            SCH_Add_Task(Self_learn_programming, 0, 0);
 329   2      //    SCH_Add_Task(Self_learn_speech, 0, 0);
 330   2            Self_learn_speech();
 331   2            }
 332   1         
 333   1         // detect whether key is rotated on,  
 334   1         if((key_rotate == 1)&&(key_rotated_on_flag == 0)&&(IDkey_flag == 1))    
 335   1            {
 336   2            Delay_1ms();
 337   2            // anti-trigger, Delay(5) confirm the key rotation.
 338   2            if(key_rotate == 1)
 339   2               {
 340   3               disable_sensor();
 341   3      
 342   3               IDkey_count = 0;
 343   3               IDkey_flag = 0;
 344   3               IDkey_certificated_times = 0;
 345   3      
 346   3      //       SCH_Add_Task(ElecMotor_CW, 0, 0);
 347   3               ElecMotor_CW();
 348   3               slave_nearby_operation();
 349   3      //       SCH_Add_Task(slave_nearby_operation, 0, 0);
 350   3               }
 351   2            }     
 352   1                  
 353   1         // detect whether key is rotated off
 354   1         if((key_rotate == 0)&&(key_rotated_on_flag == 1))
 355   1            {
 356   2            if((vibration_flag == 0)&&(wheeled_flag == 0))
 357   2               {
 358   3               Delay_1ms();
C51 COMPILER V9.51   MAIN                                                                  03/16/2015 15:12:35 PAGE 7   

 359   3               if(key_rotate == 0)
 360   3                  {
 361   4                  // reset key rotation flag
 362   4                  key_rotated_on_flag=0;
 363   4      //          SCH_Add_Task(slave_away_operation, 0, 0);
 364   4                  slave_away_operation();    
 365   4                  CheckADC_flag = 0;
 366   4                  CheckADC_count = 0;
 367   4                  }           
 368   3               }
 369   2            }
 370   1            
 371   1         if((sensor_detect == 0)||(horizontal_sensor == 0))
 372   1            {
 373   2            vibration_flag = 1;
 374   2            vibration_count = 0;
 375   2            }
 376   1          if(vibration_flag == 1)
 377   1            {
 378   2            if(++vibration_count >= 2000)
 379   2               {
 380   3               vibration_flag = 0;
 381   3               vibration_count = 0;
 382   3               }
 383   2            }
 384   1      
 385   1      
 386   1         if(wheeled_rotate == 1)
 387   1            {
 388   2            wheeled_flag = 1;
 389   2            wheeled_count = 0;
 390   2            }
 391   1         if(wheeled_flag == 1)
 392   1            {
 393   2            if(++wheeled_count >= 2000)
 394   2               {
 395   3               wheeled_flag = 0;
 396   3               wheeled_count = 0;
 397   3               }
 398   2            }
 399   1         
 400   1               
 401   1         if((sensor_detect == 0)||(horizontal_sensor == 0))
 402   1            {
 403   2            vibration_flag = 1;
 404   2            vibration_count = 0;       
 405   2            }     
 406   1            
 407   1         
 408   1      
 409   1         // judge host is fell or raised every 1ms?
 410   1      // if((raised_sensor_detect == 1)&&(fell_sensor_detect == 1))
 411   1      //    {
 412   1            // judge vibration sensor is enable?
 413   1            if(sensor_EN == 1)   
 414   1               {        
 415   2               // sensor trigger status, 0, 1 or 2?
 416   2               switch(sensor_trigger_count)
 417   2                  {
 418   3                  // case 0, it means host is in waiting status. waiting for first touch.
 419   3                  case 0:
 420   3                     {
C51 COMPILER V9.51   MAIN                                                                  03/16/2015 15:12:35 PAGE 8   

 421   4                     
 422   4                     // judge host been touched and also not in vibration alarm
 423   4      //             if((sensor_detect == 0)&&(stolen_alarm_flag == 0)&&(transmiter_EN == 1))      
 424   4                     if(((sensor_detect == 0)||(horizontal_sensor == 0))&&(stolen_alarm_flag == 0)&&(flashing_flag == 0))  
             -   
 425   4                        {
 426   5                        // judge LV is more than 2ms, if yes, it means a effective touch
 427   5                        if(++sensor_1ststage_count >= 1)       
 428   5                           {
 429   6                           sensor_1ststage_count=0;
 430   6                           
 431   6                           // sensor trigge status progress to case 1.
 432   6                           sensor_trigger_count = 1;
 433   6                           // alarm speech for first touch
 434   6      //                   SCH_Add_Task(host_touch_speech, 0, 0);
 435   6      //                   host_touch_speech();
 436   6                           Delay_500ms();
 437   6                           Delay_500ms();
 438   6                           Delay_500ms();
 439   6                           Delay_500ms();
 440   6                           }
 441   5                        }
 442   4                     else
 443   4                        {
 444   5                        // if no LV, reset the count.
 445   5                        sensor_1ststage_count = 0;
 446   5                        }
 447   4                     }
 448   3                  break;
 449   3                  
 450   3                  // waiting for next touch, 
 451   3                  case 1:
 452   3                     {
 453   4                     if((sensor_detect == 0)||(horizontal_sensor == 0))
 454   4                        {
 455   5                        // LV for 2s, means a effective touch
 456   5                        if(++sensor_2ndstage_count >= 1)
 457   5                           {
 458   6                           sensor_2ndstage_count = 0;
 459   6                           sensor_trigger_count = 2;
 460   6                           // alarm speech for 2nd touch
 461   6      //                   SCH_Add_Task(host_2ndtouch_speech, 0, 0);
 462   6                           host_touch_speech();
 463   6                           }
 464   5                        }
 465   4                     else
 466   4                        {
 467   5                        sensor_2ndstage_count = 0;
 468   5                        }
 469   4                     
 470   4                     // if there is no touch in 4s, reset sensor trigger status, etc.
 471   4                     if(++sensor_2ndstage_time >= 4000)
 472   4                        {
 473   5                        sensor_trigger_count = 0;
 474   5                        sensor_2ndstage_count = 0;
 475   5                        sensor_1ststage_count = 0;
 476   5                        sensor_2ndstage_time = 0;
 477   5                        }
 478   4                     }
 479   3                  break;
 480   3                  
 481   3                  // waiting for 3rd touch
C51 COMPILER V9.51   MAIN                                                                  03/16/2015 15:12:35 PAGE 9   

 482   3                  case 2:
 483   3                     {
 484   4                     if((sensor_detect == 0)||(horizontal_sensor == 0))
 485   4                        {
 486   5                        // 2s LV is a effective touch
 487   5                        if(++sensor_3rdstage_count >= 1)
 488   5                           {
 489   6                           sensor_3rdstage_count = 0;
 490   6                           // stolen alarm speech enable
 491   6                           host_stolen_alarm1_EN = 1;
 492   6                           host_stolen_alarm2_EN = 1; 
 493   6                           sensor_3rdalarm_flag = 1;                    
 494   6                           }
 495   5                        }
 496   4                     else
 497   4                        {
 498   5                        sensor_3rdstage_count = 0;
 499   5                        }
 500   4                     
 501   4                     // if there is no touch in 4s, reset all.
 502   4                     if(++sensor_3rdstage_time >= 4000)
 503   4                        {
 504   5                        sensor_trigger_count = 0;
 505   5                        sensor_1ststage_count = 0;
 506   5                        sensor_2ndstage_count = 0;
 507   5                        sensor_2ndstage_time = 0;
 508   5                        sensor_3rdstage_time = 0;
 509   5                        sensor_3rdstage_interval = 800;
 510   5                        sensor_3rdstage_count = 0;
 511   5                        sensor_3rdstage_effcount = 0;             
 512   5                        }
 513   4                     }
 514   3                  break;
 515   3                  }
 516   2               
 517   2               // judge the wire broken, if yes, it means someone has cut the wire of magnet lock
 518   2               if((wire_broken == 0) && (wire_broken_count < 51))  
 519   2                  {
 520   3                  if(++wire_broken_count > 50)
 521   3                     {
 522   4                     host_stolen_alarm1_EN = 1;
 523   4                     host_stolen_alarm2_EN = 1; 
 524   4                     wire_broken_count = 51;
 525   4                     }  
 526   3                  }
 527   2               else if((wire_broken == 1)&&(sensor_3rdalarm_flag == 0))
 528   2                  {
 529   3                  wire_broken_count = 0;
 530   3                  host_stolen_alarm1_EN = 0;
 531   3                  host_stolen_alarm2_EN = 0;
 532   3                  }
 533   2               
 534   2               }
 535   1      //    }
 536   1         
 537   1         // judge whether position sensor is enable
 538   1         if(position_sensor_EN==1)     
 539   1            {
 540   2            // judge whether there is a LV
 541   2            if(raised_sensor_detect == 0) 
 542   2               {
 543   3               // LV > 0.5s means a effective input
C51 COMPILER V9.51   MAIN                                                                  03/16/2015 15:12:35 PAGE 10  

 544   3               if(++raise_wire_time==10)
 545   3                  {
 546   4                  // flag raised, and reset fell
 547   4                  raised_flag=1;
 548   4                  fell_flag=0;
 549   4                  // judge whether there once been a raised or fell.
 550   4                  if(raised_fell_once_flag == 0)
 551   4                     {
 552   5                     // if no, flag raised and fell flag
 553   5                     raised_fell_flag = 1;               
 554   5                     }
 555   4                  }     
 556   3               }
 557   2            else
 558   2               {
 559   3               raised_flag=0;
 560   3               raised_alarm_count=0;
 561   3               raise_wire_time=0;
 562   3               raised_fell_flag = 0;
 563   3               }
 564   2            // judge whether there is a LV
 565   2            if(fell_sensor_detect==0)
 566   2               {
 567   3               // LV > 0.5s means a effective input
 568   3               if(++fell_wire_time==10)   
 569   3                  {
 570   4                  // flag fell, and reset raised
 571   4                  fell_flag=1;         
 572   4                  raised_flag=0;
 573   4                  // judge whether there once been a raised or fell
 574   4                  if(raised_fell_once_flag == 0)
 575   4                     {
 576   5                     raised_fell_flag = 1;               
 577   5                     }
 578   4                  }     
 579   3               }
 580   2            else
 581   2               {
 582   3               fell_flag=0;
 583   3               fell_alarm_count=0;
 584   3               fell_wire_time=0;
 585   3               raised_fell_flag = 0;
 586   3               }
 587   2            }
 588   1         
 589   1         // judge whether raised or fell, if yes, reset all after 10s.
 590   1         if(raised_fell_flag == 1)
 591   1            {
 592   2            if(++raised_fell_number >= 4000)
 593   2               {
 594   3               raised_fell_flag = 0;
 595   3               raised_fell_number = 0;
 596   3               raised_fell_once_flag = 1;
 597   3               
 598   3               sensor_trigger_count = 0;
 599   3               sensor_1ststage_count = 0;
 600   3               sensor_2ndstage_count = 0;
 601   3               sensor_2ndstage_time = 0;
 602   3               sensor_3rdstage_time = 0;
 603   3               sensor_3rdstage_interval = 800;
 604   3               sensor_3rdstage_count = 0;
 605   3               sensor_3rdstage_effcount = 0;             
C51 COMPILER V9.51   MAIN                                                                  03/16/2015 15:12:35 PAGE 11  

 606   3               }
 607   2            }
 608   1         
 609   1         // detect the horizontal sensor
 610   1         if(((horizontal_sensor == 0)||(sensor_detect == 0))&&(horizontal_vibration_count > 5000))
 611   1            {
 612   2            Delay(3);
 613   2            if((horizontal_sensor == 0)||(sensor_detect == 0))
 614   2               {
 615   3               horizontal_vibration = 1;
 616   3               horizontal_vibration_count = 0;
 617   3               }
 618   2            }
 619   1         if(++horizontal_vibration_count >= 5000)
 620   1            {
 621   2            horizontal_vibration_count = 5001;
 622   2            horizontal_vibration = 0;
 623   2            }
 624   1         }
 625          
 626          /*-----------------------------------------------
 627             UART interrupt
 628          -----------------------------------------------*/
 629          void uart_isr() interrupt 4 
 630             {
 631   1         if(RI)
 632   1            {
 633   2            RI=0;
 634   2            received_data_buffer[data_count] = SBUF;
 635   2      
 636   2            // assign one byte to buffer[i] 
 637   2            
 638   2            if(IDkey_selflearn_flag6 == 0)
 639   2               {
 640   3               // judge whether buffer[0] is CmdHead
 641   3               if((data_count == 0) && (received_data_buffer[0] == IDkey6))
 642   3                  {
 643   4                  data_count = 1;
 644   4                  }
 645   3               else if((data_count == 1) && (received_data_buffer[1] == IDkey7))
 646   3                  {
 647   4                  data_count = 2;
 648   4                  }
 649   3               else if((data_count == 2) && (received_data_buffer[2] == IDkey8))
 650   3                  {
 651   4                  data_count = 3;
 652   4                  }
 653   3               else if((data_count == 3) && (received_data_buffer[3] == IDkey9))
 654   3                  {
 655   4                  data_count = 4;
 656   4                  }
 657   3               else if((data_count == 4) && (received_data_buffer[4] == IDkey10))
 658   3                  {
 659   4                  data_count = 5;
 660   4                  }
 661   3               else if((data_count == 5) && (received_data_buffer[5] == IDkey11))
 662   3                  {
 663   4                  data_count = 0;   
 664   4                  IDkey_flag = 1;
 665   4                  IDkey_count = 0;
 666   4                  disable_sensor();
 667   4                  IDkey_speech_flash = 1;
C51 COMPILER V9.51   MAIN                                                                  03/16/2015 15:12:35 PAGE 12  

 668   4                  
 669   4                  if(IDkey_certificated_times++ >= 1)
 670   4                     {
 671   5                     Silence_Flag = 1;
 672   5                     }
 673   4                  }
 674   3               else 
 675   3                  {
 676   4                  data_count = 0;
 677   4                  }        
 678   3               }
 679   2            else
 680   2               {
 681   3               
 682   3               if(++data_count >= 6)
 683   3                  {
 684   4                  data_count = 0;
 685   4                  IDkey_flash_EN = 1;
 686   4                  }
 687   3               }
 688   2            }
 689   1         }
 690          
 691          
 692          /*---------------------------------------------------
 693             end of file
 694          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1433    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =     54    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     29    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
