C51 COMPILER V9.51   COMMUNICATION                                                         03/16/2015 15:12:36 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE COMMUNICATION
OBJECT MODULE PLACED IN .\communication.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE ..\Library\communication.c COMPACT BROWSE INCDIR(..\Lib
                    -rary) DEBUG OBJECTEXTEND PRINT(.\communication.lst) TABS(3) OBJECT(.\communication.obj)

line level    source

   1          /*---------------------------------------------------
   2             communication.c (v1.00)
   3             
   4             通信程序
   5          ---------------------------------------------------*/ 
   6          
   7          #include "main.h"
   8          #include "port.h"
   9          
  10          #include "communication.h"
  11          #include "Delay.h"
  12          #include "uart.h"
  13          
  14          /*------ private variable --------------------------*/
  15          tByte myTxRxData[7] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
  16          //tByte IDkey11 = IDkey6^IDkey7^IDkey8^IDkey9^IDkey10;
  17          
  18          /*------- Public variable declarations --------------------------*/
  19          extern tByte receive_LV_count;      
  20          extern bit receive_wire_flag;    
  21          extern tByte one_receive_byte;      
  22          extern tByte one_receive_byte_count;         
  23          extern tByte receive_HV_count;      
  24          extern tByte data_count;            
  25          extern tByte received_data_buffer[7];     
  26          extern bit receive_data_finished_flag;    
  27          
  28          extern code tByte IDkey6;
  29          extern code tByte IDkey7;
  30          extern code tByte IDkey8;
  31          extern code tByte IDkey9;
  32          extern code tByte IDkey10;
  33          
  34          /*----------------------------------------------------
  35             initsignal()
  36             
  37             初始化信号程序，接收机在接接收信号的时候，需要有
  38             一段代码来使接收机打开，而这一段程序有可能无法识别
  39             出来，而是相当于废代码，只占用通信时间。
  40          ----------------------------------------------------*/
  41          void initsignal()
  42             {
  43   1         tByte k,k1;
  44   1         tByte mystartbuffer = 0xaa;
  45   1         for(k1 = 0; k1 < 2; k1++)
  46   1            {
  47   2            for(k=0;k<8;k++)
  48   2               {
  49   3               if((mystartbuffer&0x80) == 0x80)//为1
  50   3                  {
  51   4                  P10=0;
  52   4                  Custom_Delay(46, 20);
  53   4      //          Delay_5ms();
  54   4                  }
C51 COMPILER V9.51   COMMUNICATION                                                         03/16/2015 15:12:36 PAGE 2   

  55   3               else
  56   3                  {
  57   4                  P10=0;
  58   4                  Custom_Delay(46, 20);
  59   4      //          Delay_5ms();
  60   4                  }
  61   3               P10=1;
  62   3               mystartbuffer<<=1;
  63   3               Custom_Delay(40, 24);
  64   3      //       Delay_5ms();
  65   3               }
  66   2            mystartbuffer=0xaa;
  67   2      //    Delay_5ms();
  68   2      //    Custom_Delay(23, 28);
  69   2            }
  70   1         P10=1;
  71   1         }
  72          
  73          /*--------------------------------------------------
  74             Send_Data()
  75             将数据发送出去
  76          --------------------------------------------------*/
  77          void Send_Data(tByte x)
  78             {
  79   1         tByte i,n;
  80   1         for(i=0;i<3;i++)
  81   1            {
  82   2            for(n=0;n<8;n++)
  83   2               {
  84   3               if((myTxRxData[i]&0x80)==0x80)
  85   3                  {
  86   4                  P10=0;
  87   4                  Custom_Delay(36, x);
  88   4                  }
  89   3               else
  90   3                  {
  91   4                  P10=0;
  92   4                  Custom_Delay(23, x);
  93   4                  }
  94   3               P10=1;
  95   3               myTxRxData[i]<<=1;
  96   3               Custom_Delay(20, x);
  97   3               }
  98   2            }  
  99   1         }
 100          
 101          /*--------------------------------------------------
 102             ComMode_Data()
 103             
 104             主机接收到编码1信号后，会反馈一个编码1信号给附机
 105             以表示主机在附机附近。
 106          ---------------------------------------------------*/
 107          void ComMode_Data(tByte ComMode, x) 
 108             {
 109   1         receiver_EN = 1;
 110   1         Delay(20);
 111   1         transmiter_EN = 0;
 112   1         myTxRxData[0] = CmdHead;
 113   1         myTxRxData[1] = MyAddress;
 114   1         myTxRxData[2] = ComMode;
 115   1      
 116   1         initsignal();
C51 COMPILER V9.51   COMMUNICATION                                                         03/16/2015 15:12:36 PAGE 3   

 117   1         Send_Data(x);
 118   1         
 119   1         transmiter_EN = 1;
 120   1         receiver_EN = 1;
 121   1         }
 122          
 123          /*--------------------------------------------------
 124             ComMode_Data_WX()
 125             
 126             主机接收到编码1信号后，会反馈一个编码1信号给附机
 127             以表示主机在附机附近。
 128          ---------------------------------------------------*/
 129          void ComMode_Data_WX(tByte ComMode, x) 
 130             {
 131   1         receiver_EN = 1;
 132   1         Delay(20);
 133   1         transmiter_EN = 0;
 134   1         myTxRxData[0] = CmdHead;
 135   1         myTxRxData[1] = MyAddress;
 136   1         myTxRxData[2] = ComMode;
 137   1      
 138   1         initsignal();
 139   1         Send_Data(x);
 140   1         
 141   1         transmiter_EN = 0;
 142   1         receiver_EN = 0;
 143   1         TXD = 0;
 144   1         }
 145          
 146          /*------------------------------------------------------------------
 147             UART发送数据
 148          ------------------------------------------------------------------*/
 149          void UART_Send_Data(tByte command)
 150             {
 151   1         tByte ii = 0;
 152   1         open_tranceiver();
 153   1         myTxRxData[0] = IDkey6;
 154   1         myTxRxData[1] = IDkey7;
 155   1         myTxRxData[2] = IDkey8;
 156   1         myTxRxData[3] = IDkey9;
 157   1         myTxRxData[4] = IDkey10;
 158   1         myTxRxData[5] = command;
 159   1         
 160   1         initsignal();
 161   1         
 162   1         for(ii = 0; ii < 18; ii++)
 163   1            {
 164   2            SendNByte(myTxRxData, 6);
 165   2            Delay_50ms();     
 166   2            }
 167   1      
 168   1         close_tranceiver();
 169   1         
 170   1         }
 171          
 172          /*------------------------------------------------------------------
 173             open_tranceiver()
 174             开发射机
 175          -------------------------------------------------------------------*/
 176          void open_tranceiver(void)
 177             {
 178   1         InitUART600();
C51 COMPILER V9.51   COMMUNICATION                                                         03/16/2015 15:12:36 PAGE 4   

 179   1         receiver_EN = 1;
 180   1      // Delay(5);
 181   1         transmiter_EN = 0;   
 182   1         }
 183          
 184          /*------------------------------------------------------------------
 185             close_tranceiver()
 186             开发射机
 187          -------------------------------------------------------------------*/
 188          void close_tranceiver(void)
 189             {
 190   1         transmiter_EN = 1;
 191   1         receiver_EN = 0;
 192   1         InitUART9600();
 193   1         TR0 = 1;
 194   1         }
 195          
 196          /*------------------------------------------------------------------
 197             UART发送数据
 198          ------------------------------------------------------------------*/
 199          void UART_Send_Data_match(void)
 200             {
 201   1         InitUART600();
 202   1         receiver_EN = 1;
 203   1      // Delay(5);
 204   1         transmiter_EN = 0;
 205   1         myTxRxData[0] = CmdHead;
 206   1         myTxRxData[1] = ComMode_1;
 207   1         myTxRxData[2] = IDkey6;
 208   1         myTxRxData[3] = IDkey7;
 209   1         myTxRxData[4] = IDkey8;
 210   1         myTxRxData[5] = IDkey9;
 211   1         myTxRxData[6] = IDkey10;
 212   1         
 213   1         initsignal();
 214   1         
 215   1         SendNByte(myTxRxData, 7);
 216   1         Delay_5ms();
 217   1         SendNByte(myTxRxData, 7);
 218   1         Delay_5ms();
 219   1         SendNByte(myTxRxData, 7);
 220   1         Delay_5ms();
 221   1         
 222   1         transmiter_EN = 1;
 223   1         receiver_EN = 0;
 224   1         InitUART9600();
 225   1         TR0 = 1;
 226   1         }
 227          
 228          /*-----------------------------------------------------------------------------
 229             receive_byte()
 230             receive a byte program
 231          -----------------------------------------------------------------------------*/
 232          void receive_byte(void)
 233             {
 234   1         // P11 constantly HV, if detected a LV, judge it.
 235   1         if(P11 == 0)
 236   1            {
 237   2            // count the LV time, if more than 12ms, reset it.
 238   2            if(++receive_LV_count >= 120)
 239   2               {
 240   3               receive_LV_count = 0;
C51 COMPILER V9.51   COMMUNICATION                                                         03/16/2015 15:12:36 PAGE 5   

 241   3               }
 242   2            receive_wire_flag = 0;
 243   2            }
 244   1         // if P11 return to HV
 245   1         else
 246   1            {
 247   2            // and already have LV before, so we think it maybe a bit signal
 248   2            if(receive_wire_flag == 0)
 249   2               {
 250   3               // set the flag, to judge a bit only one time
 251   3               receive_wire_flag = 1;
 252   3      
 253   3               // judge the LV time, if 3.5ms < time < 8ms, we think it is a "0". time<3.5ms means a noise.
 254   3               if((receive_LV_count > 35)&&(receive_LV_count <= 80)) 
 255   3                  {
 256   4                  // save "0" to one byte
 257   4                  one_receive_byte <<= 1;
 258   4                  one_receive_byte &= 0xfe;
 259   4                  one_receive_byte_count++;
 260   4                  receive_HV_count = 0;
 261   4                  }
 262   3               // time > 8ms, means a "1"
 263   3               else if((receive_LV_count > 80))
 264   3                  {
 265   4                  // save "1" to one byte
 266   4                  one_receive_byte <<= 1;
 267   4                  one_receive_byte |= 0x01;
 268   4                  one_receive_byte_count++;
 269   4                  receive_HV_count = 0;
 270   4                  }        
 271   3               else
 272   3                  {
 273   4                  // increase the count for HV
 274   4                  receive_HV_count++;  
 275   4                  }
 276   3               // reset LV count
 277   3               receive_LV_count = 0;
 278   3               }
 279   2            else
 280   2               {
 281   3               // judge whether HV count > 6ms, if yes, means a restart
 282   3               if(++receive_HV_count >= 60)
 283   3                  {
 284   4                  one_receive_byte_count = 0;
 285   4                  receive_wire_flag = 1;
 286   4                  data_count = 0;
 287   4                  }     
 288   3               }
 289   2            }
 290   1         }
 291          
 292          /*-----------------------------------------------------------------------------
 293             receive_word()
 294             receive a word program
 295          -----------------------------------------------------------------------------*/
 296          void receive_word(void)
 297             {
 298   1         // one byte have 8 bit, once receive a bit, the count increase, once it is 8, it means a byte received.
 299   1         if(one_receive_byte_count == 8)
 300   1            {
 301   2            one_receive_byte_count = 0;
 302   2            // assign one byte to buffer[i] 
C51 COMPILER V9.51   COMMUNICATION                                                         03/16/2015 15:12:36 PAGE 6   

 303   2            received_data_buffer[data_count] = one_receive_byte;
 304   2            
 305   2            // judge whether buffer[0] is CmdHead
 306   2            if((data_count == 0) && (received_data_buffer[0] == CmdHead))
 307   2               {
 308   3               data_count = 1;
 309   3               }
 310   2            // judge whether buffer[1] is MyAddress
 311   2            else if((data_count == 1) && (received_data_buffer[1] == MyAddress))
 312   2               {
 313   3               data_count = 2;
 314   3               }
 315   2            else if(data_count == 2)
 316   2               {
 317   3               receive_data_finished_flag = 1;
 318   3               data_count = 0;
 319   3               }
 320   2            else 
 321   2               {
 322   3               data_count = 0;
 323   3               }
 324   2            }
 325   1         }
 326          
 327          /*--------------------------------------------------
 328             send_code_to_lock()
 329             
 330             将密码发送给锁体。
 331          ---------------------------------------------------*/
 332          void send_code_to_lock(tByte x, y)  
 333          {
 334   1         unsigned char i,n;
 335   1         myTxRxData[0]=CmdHead;
 336   1         myTxRxData[1]=MyAddress;
 337   1         myTxRxData[2]=x;
 338   1      /* myTxRxData[3]=0x00;
 339   1         myTxRxData[4]=0x00;
 340   1         myTxRxData[5]=0x00;
 341   1         myTxRxData[6]=0x00;
 342   1      */
 343   1         for(i=0;i<3;i++)
 344   1         {
 345   2            for(n=0;n<8;n++)
 346   2            {
 347   3               if((myTxRxData[i]&0x80) == 0x80)//为1
 348   3               {
 349   4                  MagentControl_2 = 0;
 350   4                  Custom_Delay(36, y);
 351   4               }
 352   3               else//为0的情况
 353   3               {
 354   4                  MagentControl_2 = 0;
 355   4                  Custom_Delay(23, y);
 356   4               }
 357   3               MagentControl_2 = 1;    //常态为高电平
 358   3               myTxRxData[i] <<= 1;
 359   3               Custom_Delay(15, y);
 360   3            }
 361   2         }
 362   1      }
 363          
 364          /*--------------------------------------------------
C51 COMPILER V9.51   COMMUNICATION                                                         03/16/2015 15:12:36 PAGE 7   

 365             send_code_to_lock_Taili()
 366             
 367             将密码发送给锁体。
 368          ---------------------------------------------------*/
 369          void send_code_to_lock_Taili(tByte x, y)  
 370          {
 371   1         unsigned char i,n;
 372   1         myTxRxData[0]=CmdHead;
 373   1         myTxRxData[1]=MyAddress;
 374   1         myTxRxData[2]=x;
 375   1      /* myTxRxData[3]=0x00;
 376   1         myTxRxData[4]=0x00;
 377   1         myTxRxData[5]=0x00;
 378   1         myTxRxData[6]=0x00;
 379   1      */
 380   1         for(i=0;i<3;i++)
 381   1         {
 382   2            for(n=0;n<8;n++)
 383   2            {
 384   3               if((myTxRxData[i]&0x80) == 0x80)//为1
 385   3               {
 386   4                  lock_code = 0;
 387   4                  Custom_Delay(36, y);
 388   4               }
 389   3               else//为0的情况
 390   3               {
 391   4                  lock_code = 0;
 392   4                  Custom_Delay(23, y);
 393   4               }
 394   3               lock_code = 1;    //常态为高电平
 395   3               myTxRxData[i] <<= 1;
 396   3               Custom_Delay(15, y);
 397   3            }
 398   2         }
 399   1      }
 400          
 401          /*---------------------------------------------------
 402             end of file
 403          ----------------------------------------------------*/


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    882    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =      7      22
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
